# -*- coding: utf-8 -*-

"""
Implements the free closed monoidal category.
"""

from discopy import monoidal, biclosed, messages
from lambeq import BobcatParser


class Ty(monoidal.Ty):
    """
    Objects in a free closed monoidal category.
    Generated by the following grammar:

        ty ::= Ty(name) | ty @ ty | ty >> ty

    Examples
    --------
    >>> x, y = Ty('x'), Ty('y')
    >>> print(x >> y >> x)
    ((x → y) → x)
    >>> print((y >> x >> y) @ x)
    ((y → x) → y) @ x
    """

    def __init__(self, *objects, index=None):
        """
        Initialize the Ty class. `index` is extra information added to Ty. This is used for coindexing. 
        """
        super().__init__()
        self.index = index
        if len(objects) > 1:
            self._objects = tuple(x if isinstance(x, Ty) else Ty(x) for x in objects)
        elif len(objects) == 1:
            if isinstance(objects[0], Ty):
                if self.index == None:
                    self.index = objects[0].index
                self._objects = objects[0].downgrade()
            elif isinstance(objects[0], monoidal.Ty):
                self._objects = objects[0]
            else:
                self._objects = monoidal.Ty(objects[0])

    def __rshift__(self, other):
        """
        Define the right shift operator to create a function
        """
        return Func(self, other)

    def __str__(self):
        """
        Return the string representation of the Ty object.
        """
        return self.to_string()

    def to_string(self, index=True):
        """
        Return the string representation of the Ty object.
        """
        if index:
            if len(self._objects) > 1:
                return f'({super().__str__()}){index_to_string(self.index)}'
            return super().__str__() + f'{index_to_string(self.index)}'
        else:
            if len(self._objects) > 1:
                return ' @ '.join(map(lambda x: x.to_string(index), self._objects))
            return super().__str__()

    def tensor(self, *others):
        """
        Return the tensor product of self and others.
        """
        for other in others:
            if not isinstance(other, monoidal.Ty):
                raise TypeError(messages.type_err(monoidal.Ty, other))
        objects = []
        for t in (self,) + others:
            if len(t.objects) > 1:
                objects += t.objects
            elif len(t.objects) == 1:
                objects.append(t)
        return Ty(*objects)

    @staticmethod
    def upgrade(old):
        """
        Upgrade a monoidal.Ty to a Ty.
        """
        if len(old) == 1 and isinstance(old[0], Func):
            return old[0]
        return Ty(*old.objects)

    def downgrade(self):
        """
        Downgrade a Ty to a monoidal.Ty.
        """
        if isinstance(self, Func):
            return self
        return super().downgrade()


class Func(Ty):
    """
    A subclass of Ty representing Function objects in a free closed monoidal category.
    """
    def __init__(self, input=None, output=None, index=None):
        """
        Initialize the Func class.
        """
        name = f'({repr(input)} → {repr(output)})'
        self.input = input
        self.output = output
        super().__init__(name, index=index)

    def __repr__(self):
        """
        Return the string representation of the Func object.
        """
        return "({} → {})".format(repr(self.input), repr(self.output))

    def __str__(self):
        """
        Return the string representation of the Func object.
        """
        return self.to_string()
    
    def to_string(self, index=True):
        """
        Return the string representation of the Func object.
        """
        if isinstance(self.input, Ty) and isinstance(self.output, Ty):
            fun_str = f'({self.input.to_string(index)} → {self.output.to_string(index)})'
        else:
            fun_str = f'({self.input} → {self.output})'
        if index:
            return f'{fun_str}{index_to_string(self.index)}'
        return f'{fun_str}'

    def __eq__(self, other):
        """
        Check if two Func objects are equal.
        """
        if not isinstance(other, Func):
            return False
        return self.input == other.input and self.output == other.output

    def __hash__(self):
        """
        Return the hash value of the Func object.
        """
        return hash(repr(self))


def biclosed_to_closed(x):
    """
    Converts the biclosed types to closed types.
    """
    if isinstance(x, biclosed.Under):
        return Func(biclosed_to_closed(x.left), biclosed_to_closed(x.right))
    elif isinstance(x, biclosed.Over):
        return Func(biclosed_to_closed(x.right), biclosed_to_closed(x.left))
    elif isinstance(x, biclosed.Ty):
        return Ty(*[biclosed_to_closed(y) for y in x.objects])
    else:
        return x

def ccg_cat_to_closed(cat, word_str=None):
    """
    Converts a CCG category to a closed type.
    """
    if word_str:
        assert(type(word_str)==str)
    if cat.atomic:
        typ = biclosed_to_closed(BobcatParser._to_biclosed(cat))
    else:
        result_typ = ccg_cat_to_closed(cat.result, word_str)
        argument_typ = ccg_cat_to_closed(cat.argument, word_str)
        typ = argument_typ >> result_typ
    idx = word_str + '_' + str(cat.var) if word_str else str(cat.var)
    typ.index = set([idx])
    return typ

def downgrade_to_monoidal(typ):
    """
    Downgrades a given type to a monoidal type recursively.
    """
    if isinstance(typ, monoidal.Ob) and not isinstance(typ, monoidal.Ty):
        return typ
    elif isinstance(typ, Func):
        return Func(downgrade_to_monoidal(typ.input),
                    downgrade_to_monoidal(typ.output),
                    index=typ.index)
    elif len(typ) == 1 and isinstance(typ, Ty):
        return Ty.downgrade(typ)
    elif len(typ) > 1:
        objects = []
        for t in typ.objects:
            if isinstance(t, monoidal.Ty) and not isinstance(t, Func):
                objects.extend(t.objects)
            else:
                objects.append(downgrade_to_monoidal(t))
        typ = monoidal.Ty(*objects)
        return typ
    return typ

def uncurry_types(typ, uncurry_everything=False):
    """
    Uncurries a given type recursively. Example: (a → b → c) becomes (a x b → c).
    """
    if isinstance(typ, Func) and isinstance(typ.output, Func):
        if uncurry_everything:
            inp = uncurry_types(typ.input, uncurry_everything=True)
            out_inp = uncurry_types(typ.output.input, uncurry_everything=True)
            out_out = uncurry_types(typ.output.output, uncurry_everything=True)
        else:
            inp = typ.input
            out_inp = typ.output.input
            out_out = typ.output.output
        return uncurry_types((out_inp @ inp) >> out_out)

    else:
        return typ

def index_to_string(index):
    """
    Returns the string representation of the index.
    """
    if isinstance(index, set):
        return str(sorted(list(index)))
    return str(index)
